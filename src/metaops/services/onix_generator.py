"""
ONIX generation service - converts book metadata to ONIX XML
"""
from typing import Dict, List, Optional, Any
from datetime import date, datetime
from xml.etree.ElementTree import Element, SubElement, tostring
from xml.dom import minidom
import uuid


class ONIXGenerator:
    """Generate ONIX 3.0 XML from book metadata with rights awareness"""
    
    def __init__(self):
        self.onix_namespace = "http://ns.editeur.org/onix/3.0/reference"
    
    def generate_onix_for_book(
        self,
        book_data: Dict[str, Any],
        publisher_data: Dict[str, Any],
        authors: List[Dict[str, Any]],
        contracts: Optional[List[Dict[str, Any]]] = None,
        target_territory: Optional[str] = None
    ) -> str:
        """Generate complete ONIX 3.0 XML for a book"""
        
        # Create root element
        root = Element("ONIXMessage", attrib={
            "release": "3.0",
            "xmlns": self.onix_namespace
        })
        
        # Add header
        self._add_onix_header(root, publisher_data)
        
        # Add product record
        product = SubElement(root, "Product")
        self._add_record_reference(product, book_data)
        self._add_notification_type(product)
        self._add_product_identifiers(product, book_data)
        self._add_descriptive_detail(product, book_data, authors)
        self._add_collateral_detail(product, book_data)
        self._add_publishing_detail(product, book_data, publisher_data)
        
        # Add rights-aware sales rights
        if contracts:
            self._add_sales_rights_from_contracts(product, contracts, target_territory)
        else:
            self._add_default_sales_rights(product, publisher_data.get('territory_codes', ['US']))
        
        self._add_product_supply(product, book_data)
        
        # Format and return pretty XML
        return self._prettify_xml(root)
    
    def _add_onix_header(self, root: Element, publisher_data: Dict) -> None:
        """Add ONIX message header"""
        header = SubElement(root, "Header")
        
        sender = SubElement(header, "Sender")
        sender_name = SubElement(sender, "SenderName")
        sender_name.text = publisher_data.get('name', 'Unknown Publisher')
        
        contact_name = SubElement(sender, "ContactName")  
        contact_name.text = "Metadata Team"
        
        email_address = SubElement(sender, "EmailAddress")
        email_address.text = "metadata@publisher.com"
        
        sent_datetime = SubElement(header, "SentDateTime")
        sent_datetime.text = datetime.now().strftime("%Y%m%dT%H%M")
        
        message_note = SubElement(header, "MessageNote")
        message_note.text = f"Generated by MetaOps Publisher Management System"
    
    def _add_record_reference(self, product: Element, book_data: Dict) -> None:
        """Add unique record reference"""
        record_reference = SubElement(product, "RecordReference")
        record_reference.text = book_data.get('id', str(uuid.uuid4()))
    
    def _add_notification_type(self, product: Element) -> None:
        """Add notification type (03 = Notification confirmed on publication)"""
        notification_type = SubElement(product, "NotificationType")
        notification_type.text = "03"
    
    def _add_product_identifiers(self, product: Element, book_data: Dict) -> None:
        """Add product identifiers (ISBN)"""
        if book_data.get('isbn'):
            product_identifier = SubElement(product, "ProductIdentifier")
            
            product_id_type = SubElement(product_identifier, "ProductIDType")
            product_id_type.text = "15"  # ISBN-13
            
            id_value = SubElement(product_identifier, "IDValue")
            id_value.text = book_data['isbn']
    
    def _add_descriptive_detail(self, product: Element, book_data: Dict, authors: List[Dict]) -> None:
        """Add descriptive details including title and contributors"""
        descriptive_detail = SubElement(product, "DescriptiveDetail")
        
        # Product composition (single-component retail product)
        product_composition = SubElement(descriptive_detail, "ProductComposition")
        product_composition.text = "00"
        
        # Product form
        product_form = SubElement(descriptive_detail, "ProductForm")
        product_form.text = book_data.get('product_form', 'BB')  # Default to hardback
        
        # Title detail
        title_detail = SubElement(descriptive_detail, "TitleDetail")
        title_type = SubElement(title_detail, "TitleType")
        title_type.text = "01"  # Distinctive title
        
        title_element = SubElement(title_detail, "TitleElement")
        title_element_level = SubElement(title_element, "TitleElementLevel")
        title_element_level.text = "01"  # Product level
        
        title_text = SubElement(title_element, "TitleText")
        title_text.text = book_data['title']
        
        if book_data.get('subtitle'):
            subtitle = SubElement(title_element, "Subtitle")
            subtitle.text = book_data['subtitle']
        
        # Contributors (authors)
        for idx, author in enumerate(authors):
            contributor = SubElement(descriptive_detail, "Contributor")
            
            sequence_number = SubElement(contributor, "SequenceNumber")
            sequence_number.text = str(idx + 1)
            
            contributor_role = SubElement(contributor, "ContributorRole")
            contributor_role.text = author.get('contributor_type', 'A01')  # Author
            
            person_name = SubElement(contributor, "PersonName")
            person_name.text = author['name']
            
            if author.get('biography'):
                biographical_note = SubElement(contributor, "BiographicalNote")
                biographical_note.text = author['biography'][:500]  # Limit length
    
    def _add_collateral_detail(self, product: Element, book_data: Dict) -> None:
        """Add marketing text and descriptions"""
        # For now, create basic text detail
        collateral_detail = SubElement(product, "CollateralDetail")
        
        # Create a basic description from available data
        if book_data.get('subtitle'):
            text_content = SubElement(collateral_detail, "TextContent")
            text_type = SubElement(text_content, "TextType")
            text_type.text = "03"  # Description
            
            content_audience = SubElement(text_content, "ContentAudience")
            content_audience.text = "00"  # Unrestricted
            
            text = SubElement(text_content, "Text")
            text.text = f"{book_data['title']}: {book_data['subtitle']}"
    
    def _add_publishing_detail(self, product: Element, book_data: Dict, publisher_data: Dict) -> None:
        """Add publishing information"""
        publishing_detail = SubElement(product, "PublishingDetail")
        
        # Imprint
        if publisher_data.get('imprint'):
            imprint = SubElement(publishing_detail, "Imprint")
            imprint_name = SubElement(imprint, "ImprintName")
            imprint_name.text = publisher_data['imprint']
        
        # Publisher
        publisher = SubElement(publishing_detail, "Publisher")
        publishing_role = SubElement(publisher, "PublishingRole")
        publishing_role.text = "01"  # Publisher
        
        publisher_name = SubElement(publisher, "PublisherName")
        publisher_name.text = publisher_data['name']
        
        # Publication date
        if book_data.get('publication_date'):
            publishing_date = SubElement(publishing_detail, "PublishingDate")
            publishing_date_role = SubElement(publishing_date, "PublishingDateRole")
            publishing_date_role.text = "01"  # Publication date
            
            # Parse date string
            pub_date = book_data['publication_date']
            if isinstance(pub_date, str):
                try:
                    parsed_date = datetime.fromisoformat(pub_date.replace('Z', '+00:00'))
                    date_format = SubElement(publishing_date, "DateFormat")
                    date_format.text = "00"  # YYYYMMDD
                    
                    date_value = SubElement(publishing_date, "Date")
                    date_value.text = parsed_date.strftime("%Y%m%d")
                except:
                    pass  # Skip invalid dates
    
    def _add_sales_rights_from_contracts(
        self, 
        product: Element, 
        contracts: List[Dict], 
        target_territory: Optional[str]
    ) -> None:
        """Add rights-aware sales rights based on active contracts"""
        
        # Collect all territories from contracts
        allowed_territories = set()
        restricted_territories = set()
        
        for contract in contracts:
            territory_restrictions = contract.get('territory_restrictions', [])
            if territory_restrictions:
                allowed_territories.update(territory_restrictions)
        
        if allowed_territories:
            sales_rights = SubElement(product, "SalesRights")
            sales_rights_type = SubElement(sales_rights, "SalesRightsType")
            sales_rights_type.text = "01"  # For sale with exclusive rights
            
            territory = SubElement(sales_rights, "Territory")
            countries_included = SubElement(territory, "CountriesIncluded")
            countries_included.text = " ".join(sorted(allowed_territories))
        
        # Add "not for sale" for rest of world if we have restrictions
        if allowed_territories:
            sales_rights_restricted = SubElement(product, "SalesRights")
            sales_rights_type_restricted = SubElement(sales_rights_restricted, "SalesRightsType")
            sales_rights_type_restricted.text = "03"  # Not for sale
            
            territory_restricted = SubElement(sales_rights_restricted, "Territory")
            regions_excluded = SubElement(territory_restricted, "RegionsExcluded")
            regions_excluded.text = "ROW"  # Rest of world
    
    def _add_default_sales_rights(self, product: Element, territories: List[str]) -> None:
        """Add default sales rights when no specific contracts"""
        sales_rights = SubElement(product, "SalesRights")
        sales_rights_type = SubElement(sales_rights, "SalesRightsType")
        sales_rights_type.text = "01"  # For sale with exclusive rights
        
        territory = SubElement(sales_rights, "Territory")
        countries_included = SubElement(territory, "CountriesIncluded")
        countries_included.text = " ".join(territories)
    
    def _add_product_supply(self, product: Element, book_data: Dict) -> None:
        """Add basic product supply information"""
        product_supply = SubElement(product, "ProductSupply")
        
        # Market
        market = SubElement(product_supply, "Market")
        territory = SubElement(market, "Territory")
        countries_included = SubElement(territory, "CountriesIncluded")
        countries_included.text = "WORLD"  # Default to worldwide availability
        
        # Market publishing detail
        market_publishing_detail = SubElement(product_supply, "MarketPublishingDetail")
        market_publishing_status = SubElement(market_publishing_detail, "MarketPublishingStatus")
        market_publishing_status.text = "04"  # Active
        
        # Supply detail
        supply_detail = SubElement(product_supply, "SupplyDetail")
        supplier = SubElement(supply_detail, "Supplier")
        supplier_role = SubElement(supplier, "SupplierRole")
        supplier_role.text = "09"  # Publisher to end-customers
        
        supplier_name = SubElement(supplier, "SupplierName")
        supplier_name.text = "Publisher Direct"
        
        product_availability = SubElement(supply_detail, "ProductAvailability")
        product_availability.text = "21"  # Available
    
    def _prettify_xml(self, element: Element) -> str:
        """Return a pretty-printed XML string"""
        rough_string = tostring(element, encoding='unicode')
        reparsed = minidom.parseString(rough_string)
        return reparsed.toprettyxml(indent="  ")
    
    def generate_onix_preview(self, book_data: Dict, max_length: int = 1000) -> str:
        """Generate a truncated ONIX preview for UI display"""
        full_xml = self.generate_onix_for_book(
            book_data=book_data,
            publisher_data={"name": "Preview Publisher", "imprint": "Preview"},
            authors=[{"name": "Preview Author", "contributor_type": "A01"}]
        )
        
        if len(full_xml) > max_length:
            return full_xml[:max_length] + "\n... [truncated for preview]"
        return full_xml